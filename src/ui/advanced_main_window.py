import logging
import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext
import threading
import asyncio
import time
from typing import Optional, Dict, List
import json

from .styles import HawkVanceStyle
from .components import ScrolledText, StatusBar
from config.settings import WINDOW_CONFIG, THEME, GEMINI_API_KEY
from ..core.capture import AdvancedScreenCapture, ComprehensiveCapture

class AdvancedMainWindow(tk.Tk):
    """Advanced main window with comprehensive AI capabilities"""
    
    def __init__(self):
        super().__init__()
        
        # Make window stay on top
        self.attributes('-topmost', True)
        
        # Initialize advanced components
        self.advanced_capture = None
        self.ocr_processor = None
        self.text_processor = None
        self.document_exporter = None
        
        # Response and context history
        self.response_history = []
        self.context_history = []
        self.current_response_index = -1
        
        # Capture settings
        self.capture_interval = 10  # seconds
        self.auto_capture_enabled = False
        self.continuous_monitoring = False
        
        # Configure window
        self.title(f"{WINDOW_CONFIG['title']} - Advanced AI")
        self.geometry(f"{WINDOW_CONFIG['width']+200}x{WINDOW_CONFIG['height']+100}")
        self.minsize(WINDOW_CONFIG['min_width'], WINDOW_CONFIG['min_height'])\n        \n        # Apply styles\n        self.style = HawkVanceStyle.configure_styles()\n        \n        # Configure grid\n        self.grid_rowconfigure(1, weight=1)\n        self.grid_columnconfigure(0, weight=1)\n        \n        # Create components\n        self._create_title_bar()\n        self._create_main_content()\n        self._create_status_bar()\n        self._create_settings_panel()\n        \n        # Setup async loop for advanced features\n        self.loop = None\n        self.loop_thread = None\n        self._setup_async_loop()\n    \n    def _setup_async_loop(self):\n        \"\"\"Setup async event loop for advanced processing\"\"\"\n        def run_loop():\n            self.loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(self.loop)\n            self.loop.run_forever()\n        \n        self.loop_thread = threading.Thread(target=run_loop, daemon=True)\n        self.loop_thread.start()\n        \n        # Wait for loop to be ready\n        while self.loop is None:\n            time.sleep(0.1)\n    \n    def initialize_components(self, **components):\n        \"\"\"Initialize core components with advanced features\"\"\"\n        self.ocr_processor = components.get('ocr_processor')\n        self.text_processor = components.get('text_processor')\n        self.document_exporter = components.get('document_exporter')\n        \n        # Initialize advanced screen capture\n        self.advanced_capture = AdvancedScreenCapture(gemini_api_key=GEMINI_API_KEY)\n        \n        # Enable functionality\n        self._setup_event_handlers()\n        \n        logging.info(\"Advanced components initialized successfully\")\n    \n    def _create_title_bar(self):\n        \"\"\"Create enhanced title bar with advanced controls\"\"\"\n        title_bar = ttk.Frame(self, style='TitleBar.TFrame')\n        title_bar.grid(row=0, column=0, sticky='ew')\n        \n        # Title\n        title = ttk.Label(title_bar, \n                         text=f\"{WINDOW_CONFIG['title']} - Advanced AI\",\n                         foreground=THEME['text_light'],\n                         background=THEME['primary'],\n                         font=('Segoe UI', 12, 'bold'))\n        title.pack(side='left', padx=10)\n        \n        # Control buttons\n        controls = ttk.Frame(title_bar, style='TitleBar.TFrame')\n        controls.pack(side='right', padx=5)\n        \n        # Advanced capture modes\n        self.smart_capture_button = ttk.Button(controls, text='üß† Smart Capture', \n                                              style='HawkVance.TButton')\n        self.smart_capture_button.pack(side='left', padx=2)\n        \n        self.auto_capture_button = ttk.Button(controls, text='‚èØÔ∏è Auto Capture', \n                                             style='Nav.TButton')\n        self.auto_capture_button.pack(side='left', padx=2)\n        \n        # Navigation buttons\n        self.prev_button = ttk.Button(controls, text='‚Üê', style='Nav.TButton')\n        self.prev_button.pack(side='left', padx=2)\n        \n        self.next_button = ttk.Button(controls, text='‚Üí', style='Nav.TButton')\n        self.next_button.pack(side='left', padx=2)\n        \n        # Export and settings\n        self.export_button = ttk.Button(controls, text='üìÑ Export', \n                                       style='HawkVance.TButton')\n        self.export_button.pack(side='left', padx=2)\n        \n        self.settings_button = ttk.Button(controls, text='‚öôÔ∏è', \n                                         style='Nav.TButton')\n        self.settings_button.pack(side='left', padx=2)\n    \n    def _create_main_content(self):\n        \"\"\"Create main content area with advanced features\"\"\"\n        main_frame = ttk.Frame(self, style='Content.TFrame')\n        main_frame.grid(row=1, column=0, sticky='nsew', padx=10, pady=5)\n        main_frame.grid_columnconfigure(0, weight=2)\n        main_frame.grid_columnconfigure(1, weight=1)\n        main_frame.grid_rowconfigure(0, weight=1)\n        \n        # Left panel - Main content\n        left_panel = ttk.Frame(main_frame, style='HawkVance.TFrame')\n        left_panel.grid(row=0, column=0, sticky='nsew', padx=(0, 5))\n        left_panel.grid_rowconfigure(1, weight=1)\n        left_panel.grid_columnconfigure(0, weight=1)\n        \n        # Question input\n        question_frame = ttk.Frame(left_panel, style='HawkVance.TFrame')\n        question_frame.grid(row=0, column=0, sticky='ew', pady=(0, 5))\n        question_frame.grid_columnconfigure(1, weight=1)\n        \n        ttk.Label(question_frame, text=\"Ask a question:\", \n                 style='HawkVance.TLabel').grid(row=0, column=0, padx=(0, 5))\n        \n        self.question_entry = ttk.Entry(question_frame, font=('Segoe UI', 10))\n        self.question_entry.grid(row=0, column=1, sticky='ew', padx=(0, 5))\n        \n        self.ask_button = ttk.Button(question_frame, text='ü§ñ Ask AI', \n                                    style='HawkVance.TButton')\n        self.ask_button.grid(row=0, column=2)\n        \n        # Output area with tabs\n        notebook = ttk.Notebook(left_panel)\n        notebook.grid(row=1, column=0, sticky='nsew')\n        \n        # AI Response tab\n        self.response_frame = ttk.Frame(notebook)\n        notebook.add(self.response_frame, text='ü§ñ AI Response')\n        \n        self.output_text = ScrolledText(self.response_frame, \n                                       height=20, width=60,\n                                       background=THEME['background'],\n                                       font=('Segoe UI', 10))\n        self.output_text.pack(fill='both', expand=True)\n        \n        # Context Analysis tab\n        self.context_frame = ttk.Frame(notebook)\n        notebook.add(self.context_frame, text='üìä Context Analysis')\n        \n        self.context_text = scrolledtext.ScrolledText(self.context_frame,\n                                                      height=20, width=60,\n                                                      background=THEME['background'],\n                                                      font=('Consolas', 9))\n        self.context_text.pack(fill='both', expand=True)\n        \n        # Insights tab\n        self.insights_frame = ttk.Frame(notebook)\n        notebook.add(self.insights_frame, text='üí° Insights')\n        \n        self.insights_text = scrolledtext.ScrolledText(self.insights_frame,\n                                                       height=20, width=60,\n                                                       background=THEME['background'],\n                                                       font=('Segoe UI', 9))\n        self.insights_text.pack(fill='both', expand=True)\n        \n        # Right panel - Controls and monitoring\n        self._create_control_panel(main_frame)\n    \n    def _create_control_panel(self, parent):\n        \"\"\"Create right control panel\"\"\"\n        control_panel = ttk.LabelFrame(parent, text=\"üéõÔ∏è Advanced Controls\", \n                                      style='HawkVance.TFrame')\n        control_panel.grid(row=0, column=1, sticky='nsew')\n        \n        # Capture modes\n        modes_frame = ttk.LabelFrame(control_panel, text=\"Capture Modes\")\n        modes_frame.pack(fill='x', padx=5, pady=5)\n        \n        self.mode_vars = {}\n        modes = [\n            ('basic', 'Basic Screenshot'),\n            ('scrolling', 'Smart Scrolling'),\n            ('web_full', 'Full Web Content'),\n            ('context', 'Context Awareness'),\n            ('multimodal', 'AI Analysis')\n        ]\n        \n        for mode_key, mode_label in modes:\n            var = tk.BooleanVar(value=True)\n            self.mode_vars[mode_key] = var\n            cb = ttk.Checkbutton(modes_frame, text=mode_label, variable=var,\n                               command=self._update_capture_modes)\n            cb.pack(anchor='w', padx=5, pady=2)\n        \n        # Monitoring controls\n        monitor_frame = ttk.LabelFrame(control_panel, text=\"Monitoring\")\n        monitor_frame.pack(fill='x', padx=5, pady=5)\n        \n        # Auto-capture interval\n        interval_frame = ttk.Frame(monitor_frame)\n        interval_frame.pack(fill='x', padx=5, pady=2)\n        \n        ttk.Label(interval_frame, text=\"Interval (s):\").pack(side='left')\n        self.interval_var = tk.StringVar(value=str(self.capture_interval))\n        interval_spin = ttk.Spinbox(interval_frame, from_=5, to=300, \n                                   textvariable=self.interval_var, width=6)\n        interval_spin.pack(side='right')\n        \n        # Monitoring buttons\n        self.monitor_button = ttk.Button(monitor_frame, text='üìä Start Monitoring',\n                                        style='HawkVance.TButton')\n        self.monitor_button.pack(fill='x', padx=5, pady=2)\n        \n        # Quick actions\n        actions_frame = ttk.LabelFrame(control_panel, text=\"Quick Actions\")\n        actions_frame.pack(fill='x', padx=5, pady=5)\n        \n        self.scroll_capture_button = ttk.Button(actions_frame, text='üìú Scroll Capture',\n                                               style='HawkVance.TButton')\n        self.scroll_capture_button.pack(fill='x', padx=5, pady=2)\n        \n        self.web_capture_button = ttk.Button(actions_frame, text='üåê Full Web Page',\n                                            style='HawkVance.TButton')\n        self.web_capture_button.pack(fill='x', padx=5, pady=2)\n        \n        self.summary_button = ttk.Button(actions_frame, text='üìã Activity Summary',\n                                        style='HawkVance.TButton')\n        self.summary_button.pack(fill='x', padx=5, pady=2)\n        \n        # Confidence indicator\n        confidence_frame = ttk.LabelFrame(control_panel, text=\"AI Confidence\")\n        confidence_frame.pack(fill='x', padx=5, pady=5)\n        \n        self.confidence_var = tk.StringVar(value=\"0%\")\n        self.confidence_label = ttk.Label(confidence_frame, \n                                         textvariable=self.confidence_var,\n                                         font=('Segoe UI', 12, 'bold'))\n        self.confidence_label.pack(pady=5)\n        \n        self.confidence_bar = ttk.Progressbar(confidence_frame, length=150)\n        self.confidence_bar.pack(padx=5, pady=2)\n    \n    def _create_settings_panel(self):\n        \"\"\"Create hidden settings panel\"\"\"\n        self.settings_panel = ttk.Frame(self, style='Content.TFrame')\n        # Panel is created but not gridded - will be shown/hidden as needed\n    \n    def _create_status_bar(self):\n        \"\"\"Create enhanced status bar\"\"\"\n        status_frame = ttk.Frame(self, style='TitleBar.TFrame')\n        status_frame.grid(row=2, column=0, sticky='ew')\n        \n        self.status_bar = StatusBar(status_frame)\n        self.status_bar.pack(fill='x', expand=True)\n    \n    def _setup_event_handlers(self):\n        \"\"\"Setup event handlers for all controls\"\"\"\n        # Bind Enter key to question entry\n        self.question_entry.bind('<Return>', lambda e: self._ask_ai_question())\n        \n        # Setup button commands\n        if hasattr(self, 'smart_capture_button'):\n            self.smart_capture_button.configure(command=self._smart_capture)\n        \n        if hasattr(self, 'auto_capture_button'):\n            self.auto_capture_button.configure(command=self._toggle_auto_capture)\n        \n        if hasattr(self, 'ask_button'):\n            self.ask_button.configure(command=self._ask_ai_question)\n        \n        if hasattr(self, 'scroll_capture_button'):\n            self.scroll_capture_button.configure(command=self._scroll_capture)\n        \n        if hasattr(self, 'web_capture_button'):\n            self.web_capture_button.configure(command=self._web_capture)\n        \n        if hasattr(self, 'summary_button'):\n            self.summary_button.configure(command=self._show_activity_summary)\n        \n        if hasattr(self, 'monitor_button'):\n            self.monitor_button.configure(command=self._toggle_monitoring)\n        \n        # Navigation\n        if hasattr(self, 'prev_button'):\n            self.prev_button.configure(command=self._show_previous)\n        \n        if hasattr(self, 'next_button'):\n            self.next_button.configure(command=self._show_next)\n        \n        if hasattr(self, 'export_button'):\n            self.export_button.configure(command=self._export_results)\n        \n        if hasattr(self, 'settings_button'):\n            self.settings_button.configure(command=self._toggle_settings)\n    \n    def _smart_capture(self):\n        \"\"\"Perform smart comprehensive capture\"\"\"\n        if not self.advanced_capture:\n            self.update_status(\"Advanced capture not initialized\")\n            return\n        \n        self.update_status(\"üß† Performing smart capture...\", show_progress=True)\n        \n        def capture_async():\n            try:\n                question = self.question_entry.get().strip()\n                \n                # Run comprehensive capture\n                future = asyncio.run_coroutine_threadsafe(\n                    self.advanced_capture.capture_comprehensive(question if question else None),\n                    self.loop\n                )\n                \n                result = future.result(timeout=30)  # 30 second timeout\n                \n                # Update UI with results\n                self.after(0, lambda: self._display_comprehensive_result(result))\n                \n            except Exception as e:\n                self.after(0, lambda: self.update_status(f\"Smart capture error: {str(e)}\"))\n        \n        threading.Thread(target=capture_async, daemon=True).start()\n    \n    def _display_comprehensive_result(self, result: ComprehensiveCapture):\n        \"\"\"Display comprehensive capture results\"\"\"\n        try:\n            if result.ai_analysis:\n                # Display AI response\n                self._show_response(result.ai_analysis.detailed_analysis)\n                self.response_history.append(result.ai_analysis.detailed_analysis)\n                self.current_response_index = len(self.response_history) - 1\n                \n                # Update confidence\n                confidence_percent = int(result.confidence_score * 100)\n                self.confidence_var.set(f\"{confidence_percent}%\")\n                self.confidence_bar['value'] = confidence_percent\n                \n                # Display context analysis\n                if result.application_context:\n                    context_info = {\n                        'application': {\n                            'name': result.application_context.application.process_name,\n                            'title': result.application_context.application.window_title,\n                            'memory_usage': result.application_context.application.memory_usage,\n                            'cpu_percent': result.application_context.application.cpu_percent\n                        },\n                        'content': {\n                            'visible_text_length': len(result.application_context.visible_text),\n                            'hidden_text_length': len(result.application_context.hidden_text),\n                            'ui_elements_count': len(result.application_context.ui_elements),\n                            'file_paths_count': len(result.application_context.file_paths),\n                            'urls_count': len(result.application_context.urls)\n                        },\n                        'scrolled_content_count': len(result.scrolled_content) if result.scrolled_content else 0,\n                        'web_content_available': bool(result.web_content)\n                    }\n                    \n                    self.context_text.delete('1.0', tk.END)\n                    self.context_text.insert('1.0', json.dumps(context_info, indent=2))\n                \n                # Display insights\n                if result.ai_analysis.action_suggestions:\n                    insights = \"üéØ Suggested Actions:\\n\"\n                    for i, suggestion in enumerate(result.ai_analysis.action_suggestions, 1):\n                        insights += f\"{i}. {suggestion}\\n\"\n                    \n                    insights += \"\\nü§î Follow-up Questions:\\n\"\n                    for i, question in enumerate(result.ai_analysis.follow_up_questions, 1):\n                        insights += f\"{i}. {question}\\n\"\n                    \n                    self.insights_text.delete('1.0', tk.END)\n                    self.insights_text.insert('1.0', insights)\n                \n                self.update_status(f\"‚úÖ Smart capture completed (Confidence: {confidence_percent}%)\")\n            else:\n                self.update_status(\"‚ö†Ô∏è Smart capture completed but no AI analysis available\")\n                \n        except Exception as e:\n            logging.error(f\"Error displaying comprehensive result: {e}\")\n            self.update_status(f\"Error displaying results: {str(e)}\")\n    \n    def _ask_ai_question(self):\n        \"\"\"Ask AI a specific question\"\"\"\n        question = self.question_entry.get().strip()\n        if not question:\n            messagebox.showwarning(\"Input Required\", \"Please enter a question first.\")\n            return\n        \n        self.update_status(f\"ü§ñ Asking AI: {question[:50]}...\", show_progress=True)\n        self._smart_capture()  # Use smart capture with the question\n    \n    def _scroll_capture(self):\n        \"\"\"Perform scrolling capture\"\"\"\n        if not self.advanced_capture:\n            return\n        \n        self.update_status(\"üìú Capturing scrollable content...\", show_progress=True)\n        \n        def capture_thread():\n            try:\n                results = self.advanced_capture.capture_smart_scroll()\n                \n                # Combine all text from scrolled content\n                combined_text = \"\\n\\n--- Scrolled Content ---\\n\\n\"\n                for i, result in enumerate(results, 1):\n                    combined_text += f\"Section {i}:\\n{result.text}\\n\\n\"\n                \n                self.after(0, lambda: self._show_response(combined_text))\n                self.after(0, lambda: self.update_status(f\"‚úÖ Captured {len(results)} scroll sections\"))\n                \n            except Exception as e:\n                self.after(0, lambda: self.update_status(f\"Scroll capture error: {str(e)}\"))\n        \n        threading.Thread(target=capture_thread, daemon=True).start()\n    \n    def _web_capture(self):\n        \"\"\"Capture full web page content\"\"\"\n        if not self.advanced_capture:\n            return\n        \n        self.update_status(\"üåê Capturing full web content...\", show_progress=True)\n        \n        def capture_thread():\n            try:\n                web_content = self.advanced_capture.web_intelligence.monitor_web_activity()\n                \n                if 'error' in web_content:\n                    self.after(0, lambda: self.update_status(\"‚ùå Could not detect current webpage\"))\n                    return\n                \n                content_text = web_content.get('full_combined_content', 'No content available')\n                self.after(0, lambda: self._show_response(content_text))\n                self.after(0, lambda: self.update_status(\"‚úÖ Web content captured successfully\"))\n                \n            except Exception as e:\n                self.after(0, lambda: self.update_status(f\"Web capture error: {str(e)}\"))\n        \n        threading.Thread(target=capture_thread, daemon=True).start()\n    \n    def _show_activity_summary(self):\n        \"\"\"Show activity summary\"\"\"\n        if not self.advanced_capture:\n            return\n        \n        try:\n            summary = self.advanced_capture.get_intelligent_summary(hours=1)\n            self._show_response(summary)\n            self.update_status(\"üìã Activity summary generated\")\n        except Exception as e:\n            self.update_status(f\"Summary error: {str(e)}\")\n    \n    def _toggle_auto_capture(self):\n        \"\"\"Toggle automatic capture\"\"\"\n        self.auto_capture_enabled = not self.auto_capture_enabled\n        \n        if self.auto_capture_enabled:\n            self.auto_capture_button.configure(text='‚è∏Ô∏è Stop Auto')\n            self.update_status(\"üîÑ Auto-capture enabled\")\n            self._start_auto_capture()\n        else:\n            self.auto_capture_button.configure(text='‚ñ∂Ô∏è Start Auto')\n            self.update_status(\"‚èπÔ∏è Auto-capture disabled\")\n    \n    def _start_auto_capture(self):\n        \"\"\"Start automatic capture loop\"\"\"\n        if not self.auto_capture_enabled:\n            return\n        \n        try:\n            self.capture_interval = int(self.interval_var.get())\n        except ValueError:\n            self.capture_interval = 10\n        \n        self._smart_capture()\n        \n        # Schedule next capture\n        self.after(self.capture_interval * 1000, self._start_auto_capture)\n    \n    def _toggle_monitoring(self):\n        \"\"\"Toggle continuous monitoring\"\"\"\n        self.continuous_monitoring = not self.continuous_monitoring\n        \n        if self.continuous_monitoring:\n            self.monitor_button.configure(text='‚èπÔ∏è Stop Monitoring')\n            if self.advanced_capture:\n                self.advanced_capture.enable_continuous_context_monitoring()\n            self.update_status(\"üìä Continuous monitoring enabled\")\n        else:\n            self.monitor_button.configure(text='üìä Start Monitoring')\n            self.update_status(\"‚èπÔ∏è Continuous monitoring disabled\")\n    \n    def _update_capture_modes(self):\n        \"\"\"Update capture modes based on checkboxes\"\"\"\n        if self.advanced_capture:\n            modes = {}\n            for mode_key, var in self.mode_vars.items():\n                modes[mode_key] = var.get()\n            \n            self.advanced_capture.set_capture_modes(**modes)\n            self.update_status(\"üéõÔ∏è Capture modes updated\")\n    \n    def _show_response(self, response: str):\n        \"\"\"Display response in the output area\"\"\"\n        self.output_text.text.config(state='normal')\n        self.output_text.text.delete('1.0', tk.END)\n        \n        # Add timestamp\n        timestamp = time.strftime(\"%H:%M:%S\")\n        self.output_text.text.insert('1.0', f\"[{timestamp}] \")\n        \n        # Format and display response\n        self.output_text.text.insert(tk.END, response)\n        self.output_text.text.config(state='disabled')\n    \n    def _show_previous(self):\n        \"\"\"Show previous response\"\"\"\n        if self.response_history and self.current_response_index > 0:\n            self.current_response_index -= 1\n            self._show_response(self.response_history[self.current_response_index])\n    \n    def _show_next(self):\n        \"\"\"Show next response\"\"\"\n        if self.response_history and self.current_response_index < len(self.response_history) - 1:\n            self.current_response_index += 1\n            self._show_response(self.response_history[self.current_response_index])\n    \n    def _export_results(self):\n        \"\"\"Export current results to PDF\"\"\"\n        if not self.document_exporter:\n            self.update_status(\"Error: Document exporter not initialized\")\n            return\n        \n        try:\n            self.update_status(\"üìÑ Exporting to PDF...\", show_progress=True)\n            \n            # Prepare export data\n            export_data = {\n                'response_history': self.response_history,\n                'context_analysis': self.context_text.get('1.0', tk.END),\n                'insights': self.insights_text.get('1.0', tk.END)\n            }\n            \n            # Export to PDF\n            output_path = self.document_exporter.export_to_pdf(export_data)\n            self.update_status(f\"‚úÖ Exported successfully to: {output_path}\")\n            \n        except Exception as e:\n            self.update_status(f\"‚ùå Export failed: {str(e)}\")\n            logging.error(f\"Export error: {str(e)}\", exc_info=True)\n    \n    def _toggle_settings(self):\n        \"\"\"Toggle settings panel visibility\"\"\"\n        # Placeholder for settings panel toggle\n        self.update_status(\"‚öôÔ∏è Settings panel (coming soon)\")\n    \n    def update_status(self, message: str, show_progress: bool = False):\n        \"\"\"Update status bar message\"\"\"\n        if hasattr(self, 'status_bar'):\n            self.status_bar.set_status(message, show_progress)\n        \n        logging.info(f\"Status: {message}\")\n    \n    def on_closing(self):\n        \"\"\"Handle window closing\"\"\"\n        # Stop async loop\n        if self.loop and self.loop.is_running():\n            self.loop.call_soon_threadsafe(self.loop.stop)\n        \n        # Stop monitoring\n        self.auto_capture_enabled = False\n        self.continuous_monitoring = False\n        \n        self.destroy()